class DeduktiEditorView {

  constructor() {
    // Data :
    this.FocusView = [];
    this.initialized = false;

  }

  getDefaultLocation() {
    // This location will be used if the user hasn't overridden it by dragging the item elsewhere.
    // Valid values are "left", "right", "bottom", and "center" (the default).
    return 'right';
  }

  getAllowedLocations() {
    // The locations into which the item can be moved.
    return ['right'];
  }

  initialize(){

    // Web page generated by the dom API

    // Create root element
    this.element = this.createCustomElement(
      "div",
      ["dedukti-editor"],
      [{ name: "id", value: "proofview" }],
      null,
      null
    );

    //First title
    this.proof = this.createCustomElement(
      "h2",
      ["highlight", "title-goals"],
      [],
      "Goals",
      this.element
    );

    //The List of unresolved goals
    this.list_of_proof = this.createCustomElement(
      "ol",
      ["goalstable"],
      [],
      null,
      this.element
    );

    //Second Title
    this.focus = this.createCustomElement(
      "h2",
      ["highlight", "title-focus"],
      [],
      "Focus",
      this.element
    );

    //List of Hypothesis :
    this.list_of_hypothesis = this.createCustomElement(
      "table",
      ["list_of_hypothesis"],
      [{ name: "align", value: "center" }],
      null,
      this.element
    );

    //bar
    this.bar = this.createCustomElement(
      "hr",
      ["bar-proof"],
      [],
      null,
      this.element
    );

    //Current objective
    this.current_objective = this.createCustomElement(
      "h3",
      ["proof-objectif", "text-highlight"],
      [],
      "",
      this.element
    );

    //Button toolbar at the buttom of the page :
    this.div_button = this.createCustomElement(
      "div",
      ["btn-toolbar", "proof-button"],
      [{name : "align", value:"center"}],
      null,
      this.element
    );

    //First group of buttons :
    this.div_button_first = this.createCustomElement(
      "div",
      ["btn-group","proof-button"],
      [],
      null,
      this.div_button
    );

    // Buttons :

    this.but3 = this.createCustomElement(
      "button",
      ["btn"],
      [{ name: "id", value: "third" }],
      "Previous Step",
      this.div_button_first
    );

    this.but2 = this.createCustomElement(
      "button",
      ["btn"],
      [{ name: "id", value: "second" }],
      "Next Step",
      this.div_button_first
    );


    // We consider that the view is now initialized
    this.initialized = true;
  }

  isInitialized(){ // This function is used to check if the basic elements of the view are created
    return this.initialized;
  }

  /* This function helps us creating the element we need on our web page */
  createCustomElement(type, classlist, attributes, textcontent, parentnode) {

    //It is just of wrapper around the DOM API to clean the code.
    let element = document.createElement(type);
    let i;

    for (i = 0; i < classlist.length; i++) {
      element.classList.add(classlist[i]);
    }

    for (i = 0; i < attributes.length; i++) {
      element.setAttribute(attributes[i].name, attributes[i].value);
    }

    if (textcontent != null) {
      element.textContent = textcontent;
    }

    if (parentnode != null) {
      parentnode.appendChild(element);
    }

    return element;
  }

  /* A couple of basic functions to handle the view */
  getElement() {
    return this.element;
  }

  getTitle() {
    // Title of the Information Panel
    return "Proof Assistant";
  }

  getURI() {
    // Title of the Information Panel
    return "atom://dedukti-editor-info";
  }

  // Returns an object that can be retrieved when package is activated
  serialize() {}

  // Tear down any state and detach
  destroy() {
    this.element.remove();
  }



  // A function to update the focus part of the view when it's needed
  updateView(selection, editor) {
    let path = editor.getPath();
    let i = 0;
    // We check that the selection is actually a point
    // We use selection because for the moment we think it's better not to update the view when the user selects a large part of text
    if (
      selection.newScreenRange.start.row == selection.newScreenRange.end.row &&
      selection.newScreenRange.start.column ==
        selection.newScreenRange.end.column
    ) {
      // we create some alias to clean the code
      let row = selection.newScreenRange.start.row;
      let column = selection.newScreenRange.start.column;
      let none_objective = 0; // if no FocusView is associated with the cursor position

      for (i = 0; i < this.FocusView.length; i++) {
        // we find the focusView associated with the cursor position
        if (
          this.rangewithin(
            this.FocusView[i].path,
            this.FocusView[i].range.start.line,
            this.FocusView[i].range.end.line,
            this.FocusView[i].range.start.character,
            this.FocusView[i].range.end.character,
            path,
            row,
            column
          )
        ) {
          // we display the information contained in the focusView.
          this.setCurrentObjectif(this.FocusView[i].goal);
          this.setHypothesis(this.FocusView[i].hypothesis);
          this.setGoals(this.FocusView[i].goals);
          this.markGoal(this.FocusView[i]);   // we want to provide some visual information to the user.
          none_objective = 1;                 // We can now consider that we found a data within our tab that correspond to the situation
        }
      }
      if (none_objective === 0) {
        //If no FocusView is associated with the cursor position
        this.setCurrentObjectif(""); // The currentObjective is set to null.
        this.cleanHypothesis(); //We clean every hypothesis.
        this.cleanGoals(); //We clean every goals.
      }
    }
  }

  /* A couple of functions to update each part of the view */

  //update the current objective
  setCurrentObjectif(current) {
    this.current_objective.innerText = current;
  }

  //update the hypothesis list
  setHypothesis(hypothesis) {
    let i = 0;
    this.cleanHypothesis(); // We begin by erasing what was displayed before on the hypothesis list

    // Then, we display the hypothesis we want
    for (i = 0; i < hypothesis.length; i++) {
      let list_element = this.createCustomElement( // we begin by creating a tab
        "tr",                   //type
        ["focus_data"],         //classList
        [],                     //attributes
        null,                   // textContent
        this.list_of_hypothesis // parent node
      );

      let firstcol = this.createCustomElement(     // then the first column
        "td",
        ["hyponame"],
        [],
        hypothesis[i].hname, // we display in it the name
        list_element
      );

      let secondcol = this.createCustomElement(   // then the second column
        "td",
        ["hypodot"],
        [],
        " : ", // we display in it a small separator
        list_element
      );

      let thirdcol = this.createCustomElement(  // then the third column
        "td",
        ["hypotype"],
        [],
        hypothesis[i].htype, // we display in it the type
        list_element
      );


    }
  }

  //update the goals list
  setGoals(goallist, editor) {
    this.cleanGoals(); // We begin by erasing what was displayed before on the goals list
    let i = 0;

    for (i = 0; i < goallist.length; i++) { // for each goal, we add an element in the list
      let line = this.createCustomElement(
        "li",                 //type
        ["goallistelement"],  //classList
        [],                   //attributes
        goallist[i],          //textcontent
        this.list_of_proof    //parent node
      );
    }
  }

  /* A couple of functions to clean the view */
  cleanHypothesis() {
    while (this.list_of_hypothesis.firstChild) {
      this.list_of_hypothesis.removeChild(this.list_of_hypothesis.firstChild);
    }
  }

  cleanGoals() {
    while (this.list_of_proof.firstChild) {
      this.list_of_proof.removeChild(this.list_of_proof.firstChild);
    }
  }

  /* A couple of functions to enhance the user experience */

  //The aim of this function is to help the user finding which part of the goals list is related to the focus.
  markGoal(dataview) {

    let goals = this.list_of_proof.getElementsByClassName("goallistelement"); // we find every element currently in the goalslist

    let i = 0;

    for(i=0; i < goals.length;i++) { //for each of those elements
      if(goals[i].textContent === dataview.goal){ //we check if its type is the same as the current goal
        goals[i].classList.add("text-info"); //if yes, we highlight it
      }
      else if (goals[i].classList.contains("text-info")){ //if no, we remove the higlighting if necessary
        goals[i].classList.remove("text-info");
      }
    }
  }

  /* Two functions to handle key binding */
  nextFocus() {
    //All variables we need
    let editor = atom.workspace.getActiveTextEditor();
    let cursor = editor.getCursorScreenPosition();
    let path = editor.getPath();
    //This function return the closest next focus view to our current cursor.
    let point = this.closestNextRange(path, cursor.row, cursor.column);

    if (point != null) {
      //We check that a next focus view actually exists.
      editor.setCursorScreenPosition([point.line, point.character]); //We move the cursor
    }
  }

  lastFocus() {
    //Same as nextFocus
    let editor = atom.workspace.getActiveTextEditor();
    let cursor = editor.getCursorScreenPosition();
    let path = editor.getPath();
    let point = this.closestLastRange(path, cursor.row, cursor.column);

    if (point != null) {
      editor.setCursorScreenPosition([point.line, point.character]);
    }
  }

  /* A couple of functions to deal with ranges */
  rangewithin(dvpath, dvRS, dvRE, dvCS, dvCE, apath, aR, aC) {
    /*This function returns a boolean, his value is true when the cursor symbolised by aRow (aR) and aColumn (aC) is within the range
    defined by the dvRowStart, dvRowEnd, dvColumnStart and dvColumnEnd (and of course on the same file)
    */
    if (dvpath != apath) {
      return false;
    }
    if (dvRS > aR) {
      return false;
    }
    if (dvRE < aR) {
      return false;
    }
    if (dvRS === aR && dvCS > aC) {
      return false;
    }
    if (dvRE === aR && dvCE < aC) {
      return false;
    }

    return true;
  }

  closestLastRange(path, row, column) {
    let i;
    let candidate = [];
    let min;
    let min_index;

    //We compute the distance between each FocusView and the cursor, then we gather the results in an array called candidate
    for (i = 0; i < this.FocusView.length; i++) {
      if (this.FocusView[i].path === path) {
        if (this.FocusView[i].range.end.line < row) { // we check it is efficient to compute the distance between the two
          let travel = row - this.FocusView[i].range.end.line;
          candidate.push({
            distance: travel,
            index: i
          });
        } else if (this.FocusView[i].range.end.line === row) {
          if (this.FocusView[i].range.end.character < column) {
            let travel = (column - this.FocusView[i].range.end.character) / 10;
            candidate.push({
              distance: travel,
              index: i
            });
          }
        }
      }
    }
    //We return the smallest distance
    if (candidate.length > 0) {
      min = candidate[0].distance;
      min_index = candidate[0].index;
      for (i = 1; i < candidate.length; i++) {
        if (candidate[i].distance < min) {
          min = candidate[i].distance;
          min_index = candidate[i].index;
        }
      }
      return this.FocusView[min_index].range.end;
    }
    //In case there is no next FocusView
    return null;
  }

  //Exactly the same as closestLastRange except some details
  closestNextRange(path, row, column) {
    let i;
    let candidate = [];
    let min;
    let min_index;

    for (i = 0; i < this.FocusView.length; i++) {
      if (this.FocusView[i].path === path) {
        if (this.FocusView[i].range.start.line > row) {
          let travel = this.FocusView[i].range.start.line - row;
          candidate.push({
            distance: travel,
            index: i
          });
        } else if (this.FocusView[i].range.start.line === row) {
          if (this.FocusView[i].range.start.character > column) {
            let travel =
              (this.FocusView[i].range.start.character - column) / 10;
            candidate.push({
              distance: travel,
              index: i
            });
          }
        }
      }
    }

    if (candidate.length > 0) {
      min = candidate[0].distance;
      min_index = candidate[0].index;
      for (i = 1; i < candidate.length; i++) {
        if (candidate[i].distance < min) {
          min = candidate[i].distance;
          min_index = candidate[i].index;
        }
      }
      return this.FocusView[min_index].range.end;
    }

    return null;
  }

}

exports.default = DeduktiEditorView;
